// Алгоритм Флойда Варшалла - Си. Знаходженя найкоротших шляхів між всіма парами вершин графу 
#include<stdio.h>
#include <Windows.h>

void graph_manual();
void graph_auto();

int main() 
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);


	int A = 0;   //вариант выбора
	printf("Лаб.№1 (вар.№3) Нахождение кратчайших путей между всеми парами вершин взвешенного графа (матрица расстояний),\n");
	printf("с помощью алгоритма Флойда—Уоршелла (с отрицательными весами).\n");
	printf("Введите 1 (автоматическое создание графа)\n");
	printf("Введите 2 (ручное создание графа)\n");
	scanf("%d", &A);
	if (A==1) graph_auto();
	if (A==2)  graph_manual();
	

	/* Вхiдний граф у виглядi матрицi суміжності; кожен елемент матрицi це вiдстань
	мiж парою вершини; якщо вершини не пов'язанi одина з одною, то вiдстань нескінченність (INF);
	елемент дорiвнює 0, якщо вiн на основнiй дiагоналi - вiдстань між однією і тією ж вершиною*/
		
	getchar();
	getchar();

	return 0;
}


void graph_manual()
{

	int N = 0; //количество узлов 
	printf("Введите количество узлов Графа (целое, не отрицательное):\n");
	scanf("%d", &N);


	signed int **graph = (signed int **)malloc(N * sizeof(signed int *));  // выделение динамическое памяти под двумерный массив (для задания матрицы смежности)
	for (int i = 0; i < N; i++) {
		graph[i] = (signed int *)malloc(N * sizeof(signed int));
	}

	printf("Введите значения для создания матрицы смежности взвешеного графа, \n");
	printf("в строчку через пробелы, в случае отсутствия пути между узлами указывайте значение 999, \n"); 
	printf("для основной диагонали указываем 0: \n");
	for (int i = 0; i<N; i++)
	{
		for (int j = 0; j<N; j++)
		{
			scanf("%d", &graph[i][j]);
		}
	}

	printf("Исходная матрица смежности взвешеного графа: \n");
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			printf("%7d", graph[i][j]);
		}
		printf("\n");
	}
		//Реализацiя алгоритма Флойда Варшалла - знаходженя найкоротших шляхів між всіма парами вершин графу
	// (матрица ребер [i,j], к - вершины)
	for (int kk = 0; kk < N; kk++)
	{
		for (int ii = 0; ii < N; ii++)
		{
			for (int jj = 0; jj < N; jj++)
			{
				// Якщо вершина k знаходиться на найкоротшому шляху від i до j (путь может включать больше 2ух вершин)
				//  то оновілюємо значення dist [i] [j]
				if ( graph[ii][jj] > (graph[ii][kk] + graph[kk][jj]) )
				{
					graph[ii][jj] = graph[ii][kk] + graph[kk][jj];
				}
			}
		}
	}
	/*
	 0 6 3
	-1 0 3
	 7 7 0
	 i  j     i  k     k  j                              i  j        i j k
	[0][0] > [0][0] + [0][0] ==> 0 > 0 + 0 не обновляем [0][0] = 0  (0 0 0) узел 0 со всеми
	[0][1] > [0][0] + [0][1] ==> 6 > 0 + 6 не обновляем [0][1] = 6  (0 1 0)
	[0][2] > [0][0] + [0][2] ==> 3 > 0 + 3 не обновляем [0][2] = 3  (0 2 0)	
	[1][0] > [1][0] + [0][0] ==>-1 >-1 + 0 не обновляем [1][0] =-1  (1 0 0)
	[1][1] > [1][0] + [0][1] ==> 0 >-1 + 6 не обновляем [1][1] = 0  (1 1 0)
	[1][2] > [1][0] + [0][2] ==> 3 >-1 + 3    обновляем [1][2] = 2  (1 2 0)
	[2][0] > [2][0] + [0][0] ==> 7 > 7 + 0 не обновляем [2][0] = 7  (2 0 0)
	[2][1] > [2][0] + [0][1] ==> 7 > 7 + 6 не обновляем [2][1] = 7  (2 1 0)
	[2][2] > [2][0] + [0][2] ==> 0 > 7 + 3 не обновляем [2][2] = 0  (2 2 0)
	             0 	   0			   
	[0][0] > [0][1] + [1][0] ==> 0 > 6 +-1 не обновляем [0][0] = 0  (0 0 1) узел 1 со всеми
	[0][1] > [0][1] + [1][1] ==> 6 > 6 + 0 не обновляем [0][1] = 6  (0 1 1)
	[0][2] > [0][1] + [1][2] ==> 3 > 6 + 3 не обновляем [0][2] = 3  (0 2 1)
	[1][0] > [1][1] + [1][0] ==>-1 > 0 +-1 не обновляем [1][0] =-1  (1 0 1)
	[1][1] > [1][1] + [1][1] ==> 0 > 0 + 0 не обновляем [1][1] = 0  (1 1 1)
	[1][2] > [1][1] + [1][2] ==> 2 > 0 + 3 не обновляем [1][2] = 2  (1 2 1)
	[2][0] > [2][1] + [1][0] ==> 7 > 7 +-1    обновляем [2][0] = 6  (2 0 1)
	[2][1] > [2][1] + [1][1] ==> 7 > 7 + 0 не обновляем [2][1] = 7  (2 1 1)
	[2][2] > [2][1] + [1][2] ==> 0 > 7 + 3 не обновляем [2][2] = 0  (2 2 1)
			     1     1
	[0][0] > [0][2] + [2][0] ==> 0 > 3 + 6 не обновляем [0][0] = 0  (0 0 2) узел 2 со всеми
	[0][1] > [0][2] + [2][1] ==> 6 > 3 + 7 не обновляем [0][1] = 6  (0 1 2)
	[0][2] > [0][2] + [2][2] ==> 3 > 3 + 0 не обновляем [0][2] = 3  (0 2 2)
	[1][0] > [1][2] + [2][0] ==>-1 > 3 + 6 не обновляем [1][0] =-1  (1 0 2)
	[1][1] > [1][2] + [2][1] ==> 0 > 3 + 7 не обновляем [1][1] = 0  (1 1 2)
	[1][2] > [1][2] + [2][2] ==> 2 > 3 + 0 не обновляем [1][2] = 2  (1 2 2)
	[2][0] > [2][2] + [2][0] ==> 6 > 0 + 6 не обновляем [2][0] = 6  (2 0 2)
	[2][1] > [2][2] + [2][1] ==> 7 > 0 + 7 не обновляем [2][1] = 7  (2 1 2)
	[2][2] > [2][2] + [2][2] ==> 0 > 0 + 0 не обновляем [2][2] = 0  (2 2 2)
	             2     2
    0 6 3
   -1 0 2
	6 7 0
		
	
	*/

	// Друк матриці найкоротшої відстані між кожною парою вершин 
	printf("Матрица расстояний (кратчайшие расстояния между каждой парой вершин графа): \n");
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			printf("%7d", graph[i][j]);
		}
		printf("\n");
	}
}



void graph_auto()
{

	int N = 0;  //количество узлов 
	printf("Введите количество узлов Графа (целое, не отрицательное) для автоматической генерации матрицы смежности:\n");
	scanf("%d", &N);


	signed int **graph = (signed int **)malloc(N * sizeof(signed int *));  // выделение динамическое памяти под двумерный массив (для задания матрицы смежности)
	for (int ia = 0; ia < N; ia++) {
		graph[ia] = (signed int *)malloc(N * sizeof(signed int));
	}

	// Создание рандомной матрицы смежности
	for (int i2 = 0; i2<N; i2++)
	{
		for (int j2 = 0; j2<N; j2++)
		{
			graph[i2][j2]= (rand()%10-1);  //Генератор случайного числа в диапазоне от -1..10
		
		}
	}
	for (int i3 = 0; i3<N; i3++)  // задаем 999 для нулевых значений
	{
		for (int j3 = 0; j3<N; j3++)
		{
			if (graph[i3][j3] ==0 )  graph[i3][j3] = 999;
		}
	}

	for (int i4 = 0; i4<N; i4++)  // задаем 0 для основной диагонали
	{
		graph[i4][i4] = 0;
	}



	printf("Исходная матрица смежности взвешеного графа: \n");  // А[i,j]
	for (int is = 0; is < N; is++)
	{
		for (int js = 0; js < N; js++)
		{
			printf("%7d", graph[is][js]);
		}
		printf("\n");
	}

	//Реализацiя алгоритма Флойда Варшалла - знаходженя найкоротших шляхів між всіма парами вершин графу  
	//(матрица ребер [i,j], к - вершины)
	for (int k1 = 0; k1 < N; k1++)
	{
		for (int i1 = 0; i1 < N; i1++)
		{
			for (int j1 = 0; j1 < N; j1++)
			{
				// Якщо вершина k знаходиться на найкоротшому шляху від i до j (путь может включать больше 2ух вершин)
				//  то оновілюємо значення dist [i] [j]
				if ( graph[i1][j1] > (graph[i1][k1] + graph[k1][j1] ) )
				{
					graph[i1][j1] = graph[i1][k1] + graph[k1][j1];
				}

			}
		}
	}
	// Друк матриці найкоротшої відстані між кожною парою вершин 
	printf("Матрица расстояний (кратчайшие расстояния между каждой парой вершин графа): \n");
	for (int iii = 0; iii < N; iii++)
	{
		for (int jjj = 0; jjj < N; jjj++)
		{
			printf("%7d", graph[iii][jjj]);
		}
		printf("\n");
	}
}